<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>Achieving a Static IP Using a Free Proxy</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <link rel="icon" type="image/png" href="/favicon.png" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Jason Priest </a></h1>
                <nav><ul>
                    <li><a href="/">About</a></li>
                    <li><a href="/about/projects/">Projects</a></li>
                    <li><a href="https://github.com/JustAPerson">GitHub</a></li>
                    <li><a href="/pdfs/jpriest_resume_fall_2020.pdf">Resume</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/blog/achieving-a-static-ip-using-a-free-proxy/" rel="bookmark"
           title="Permalink to Achieving a Static IP Using a Free Proxy">Achieving a Static IP Using a Free Proxy</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-12-23T00:00:00-05:00">
                Published: 2019-12-23
        </abbr>
<p>In <a href="/blog/category/linux/">Linux</a>.</p>

</footer><!-- /.post-info -->      <p>At MIT, it's fairly trivial to get a static IP address (and subdomain under
<code>mit.edu</code>) for a specific MAC address connected to their wired Ethernet network
just by emailing the IT department. Having a static IP address is very
convenient for hosting websites and game servers, but more importantly it allows
easy access to my strong desktop computer from anywhere via <a href="https://en.wikipedia.org/wiki/Secure_Shell">SSH</a>. Sadly, my
living situation has changed and I no longer have a simple static IP address for
my desktop.</p>
<p>There are two concerns to be addressed here: a static public IP address and port
forwarding. Let's start with the former. I have recently moved into an apartment
where there is only one choice of internet service provider. They offer a
reasonable consumer plan of 100Mbit/s for $40/mo with a dynamic IP. Their
cheapest business plan with a static IP is 50Mbit/s for $100/mo. Not a great
deal.</p>
<p>Now, I could probably get by with purchasing a domain and reconfiguring DNS
records every time my dynamic IP changed. For some situations, your IP address
will only change when your ISP-provided modem has been disconnected for a
long-enough time period, like during a sustained power outage. For other
situations, like where your ISP employs <a href="https://en.wikipedia.org/wiki/Carrier-grade_NAT">carrier grade NAT</a>, it may
happen more frequently. Ultimately, I don't know how frequently my public IP
address changes, and I'd prefer not to care.</p>
<p>Now onto the second concern: port forwarding. Regardless of my ISP's network
situation, we have a wireless router in our apartment for connecting multiple
devices. Thus, even if I can reliably determine our public IP address, I must
configure our router to forward connections on certain ports to my computer. I
don't control this router, and I'd prefer not to have to repeatedly badger my
roommate whenever I want to test out new services. If my ISP did employ another
layer of NAT, then this wouldn't help anyway.</p>
<p>Both of these concerns can be addressed simultaneously using a <a href="https://en.wikipedia.org/wiki/Proxy_server">proxy</a> and SSH
reverse port forwarding. </p>
<p>A commonly used flag of <code>ssh</code> is <code>-L</code>, which listens on a port of the local
machine and forwards traffic as if it originated from the remote machine. One
can also use the <code>-R</code> flag to do the opposite: to listen on the remote machine
and forward traffic as if it originated on the local machine.</p>
<p>First we will need a proxy server. You can use any host, but Google appears to
be the only major cloud provider offering an indefinite free VM at this
time<sup id="fnref:free"><a class="footnote-ref" href="#fn:free">1</a></sup>. You'll have to search for another website to describe the in-depth
steps for setting up an <code>f1-micro</code> instance on Google's cloud.</p>
<p>The basic steps for any cloud provider are as follows:</p>
<ol>
<li>Create the tiniest uninterruptible VM possible</li>
<li>Add a small hard drive if necessary</li>
<li>Select a linux distribution you're familiar with</li>
<li>Configure an SSH key</li>
<li>Configure the network rules (see below)</li>
</ol>
<p>You have a choice when configuring network rules. If you use the server-optimized
version of Ubuntu chosen by most providers, it will already come with a firewall
that will block all ports besides ssh<sup id="fnref:block"><a class="footnote-ref" href="#fn:block">2</a></sup>. This is separate from your providers
network rules, which can also block traffic destined for your VM. I would
recommend setting your cloud provider's network rules to accept traffic from all
IP addresses destined to any port. Then you only have to mess with the software
firewall<sup id="fnref:around"><a class="footnote-ref" href="#fn:around">3</a></sup>.</p>
<p>Now you can launch the VM. It will be given a static IP address that will last
until the VM is terminated. Given the reliability of modern cloud data centers,
that means you now effectively have a permanent static IP.</p>
<h1 id="setting-up-a-specific-port">Setting Up a Specific Port</h1>
<p>Say you want to run a web server on port <code>80</code>. First you need to set up the
proxy VM. This involves two things: opening the port in the software firewall
and also set up permissions for listening on that port. For Linux, a process
requires root privileges, or more specifically the <code>CAP_NET_BIND_SERVICE</code>
capability, to listen to a port below <code>1024</code>. I went with just logging in as
root<sup id="fnref:easy"><a class="footnote-ref" href="#fn:easy">4</a></sup>, but in theory you can use the <code>setcap</code> utility on <code>/usr/sbin/sshd</code>
instead.</p>
<p>In order to log in as root, on my VM I ran:</p>
<div class="highlight"><pre><span></span>sudo mkdir /root/.ssh/
sudo cp ~/.ssh/authorized_keys /root/.ssh/authorized_keys
</pre></div>


<p>You may also want to double check that your <code>/etc/ssh/sshd_config</code> lists
<code>PermitRootLogin</code> as <code>prohibit-password</code>.</p>
<p>Now you should open the port on your VM:</p>
<div class="highlight"><pre><span></span>sudo iptables -w -A INPUT -p tcp --dport <span class="m">80</span> -j ACCEPT
</pre></div>


<p>Now on your server in your local network, run the following:</p>
<div class="highlight"><pre><span></span>ssh -N -R <span class="s2">&quot;*:80:localhost:80&quot;</span> root@your.vm.ip.here
</pre></div>


<p>Remove the <code>root@</code> portion of the destination IP address if you chose to use the <code>CAP_NET_BIND_SERVICE</code> capability.</p>
<p>The <code>-N</code> flag says that SSH doesn't need to run a command on the destination; it
will remain connected indefinitely. The syntax of the <code>-R</code> flag is <code>-R
[bind_address:]port:host:hostport</code>. The <code>bind_address</code> of <code>*</code> means listen on
all network interfaces, the <code>port</code> is the port to listen to on the proxy VM, and
the <code>host</code> and <code>hostport</code> are the destination of the traffic once it has been
forwarded back to your local server. You can use the <code>-R</code> flag multiple times to
listen on multiple ports simultaneously.</p>
<p>For a basic attempt at reliability in the face of network interruptions, I wrap that command in this small script:</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="k">while</span> true<span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> connecting
  ssh -N -R <span class="s2">&quot;*:80:localhost:80&quot;</span> root@your.vm.ip.here
  <span class="nb">wait</span> <span class="m">3</span>
<span class="k">done</span>
</pre></div>


<p>Realistically, this should probably be a systemd service, but that's for another day.</p>
<h1 id="forwarding-ssh">Forwarding SSH</h1>
<p>For the time being, I mostly want to connect to my server for SSH. The easiest
option is to forward a port like <code>8192</code> on the proxy VM to port <code>22</code> on my local
server. Then I can simply add a small entry to <code>~/.ssh/config</code> and never worry about ports again:</p>
<div class="highlight"><pre><span></span>Host MyServer
    HostName my.vm.ip.here
    Port 8192
</pre></div>


<p>Now I can log in simply using <code>ssh MyServer</code>. The slightly more roundabout way
of achieving this is to make port <code>22</code> of the proxy forward to port <code>22</code> on my
server<sup id="fnref:actual"><a class="footnote-ref" href="#fn:actual">5</a></sup>. This requires first changing the what port the <code>sshd</code> running
on the proxy will listen to. I've chosen to make port <code>23</code> log in to the actual
VM whereas port <code>22</code> gets forwarded to my server.</p>
<p>First, open port <code>23</code> with <code>sudo iptables -w -A INPUT -p tcp --dport 23 -j
ACCEPT</code>. Then add <code>Port 23</code> to <code>/etc/ssh/sshd_config</code> and run <code>sudo service ssh
restart</code>. Finally, change how you invoke the ssh reverse port forwarding as so:</p>
<div class="highlight"><pre><span></span>ssh -N -R <span class="s2">&quot;*:22:localhost:22&quot;</span> root@your.vm.ip.here -p <span class="m">23</span>
</pre></div>


<p>This will drive <code>ssh</code> a little crazy because it detects that it connected to a
different computer than expected. I suppose this is quite literally a
<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle attack</a>, which <code>ssh</code> tries to prevent. You'll have to remove a
few lines from <code>~/.ssh/known_hosts</code> to quell things.</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:free">
<p>Google lists the f1-micro under their <em>Always Free</em> tier
<a href="https://cloud.google.com/free/docs/gcp-free-tier#always-free-usage-limits">here</a>. <a href="https://azure.microsoft.com/en-us/free/free-account-faq/">Azure</a> and <a href="https://aws.amazon.com/free/">AWS</a> both seem limited to 12
months.&#160;<a class="footnote-backref" href="#fnref:free" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:block">
<p><a href="https://cloud.google.com/container-optimized-os/docs/how-to/firewall">https://cloud.google.com/container-optimized-os/docs/how-to/firewall</a>&#160;<a class="footnote-backref" href="#fnref:block" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:around">
<p>You could chose the other way around: to set the software firewall to
accept all traffic and to then filter things using your provider's network
firewall. Google's web interface is terribly slow so I have not chosen this.
One could also just set both firewalls to accept all traffic. Probably not a
good idea.&#160;<a class="footnote-backref" href="#fnref:around" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:easy">
<p>Only because I did not pay attention to the capability aspect when I first encountered this issue.&#160;<a class="footnote-backref" href="#fnref:easy" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:actual">
<p>This is what I actually use because I wanted to allow somone easy
access to my desktop and I wanted it to be as convenient as possible.&#160;<a class="footnote-backref" href="#fnref:actual" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
</ol>
</div>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="https://github.com/JustAPerson/">GitHub</a></li>
                            <li><a href="mailto:jason@jpriest.me">Email</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->
</body>
</html>